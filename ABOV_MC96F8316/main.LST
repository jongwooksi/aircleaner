C51 COMPILER V9.60.0.0   MAIN                                                              07/29/2021 13:08:58 PAGE 1   


C51 COMPILER V9.60.0.0, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN main.OBJ
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE main.c LARGE OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND TABS(2)

line level    source

   1          //======================================================
   2          // Main program routine
   3          // - Device name  : MC96F8316
   4          // - Package type : 28SOP
   5          //======================================================
   6          // For XDATA variable : V1.041.00 ~
   7          #define   MAIN  1
   8          
   9          // Generated    : Tue, Jul 27, 2021 (11:47:04)
  10          #include  "MC96F8316.h"
  11          #include  "func_def.h"
  12          #include <stdio.h>
  13          #include <string.h>
  14          
  15          
  16          #define PWM0_FLAG   0x01
  17          #define PWM1_FLAG   0x02
  18          #define PWM2_FLAG   0x04
  19          #define PWM3_FLAG   0x08
  20          
  21          #define PWM_CTL_OFF   0
  22          #define PWM_CTL_INC   1
  23          #define PWM_CTL_DEC   2
  24          
  25          #define PWM_CH_NUM    4
  26          
  27          //======================================================
  28          // interrupt routines
  29          //======================================================
  30          
  31          //======================================================
  32          // peripheral setting routines
  33          //======================================================
  34          
  35          
  36          typedef struct _tagPWMINFO {
  37            int   period;
  38            int   duty;
  39            int   default_duty;
  40            int   next_duty;
  41            int   count;
  42            int   out;
  43          } PWMINFO;
  44          
  45          
  46          
  47          static unsigned int _pwm_ctl_dec_flag = 0;
  48          static unsigned int _pwm_ctl_inc_flag = 0;
  49          static unsigned int _pwm_ctl_cnt = 0;
  50          
  51          static unsigned int _pwm_flag_list[PWM_CH_NUM] = { PWM0_FLAG, PWM1_FLAG, PWM2_FLAG, PWM3_FLAG };
  52          
  53          
  54          
  55          // ----------------------------------
C51 COMPILER V9.60.0.0   MAIN                                                              07/29/2021 13:08:58 PAGE 2   

  56          static int _pwm_mask = 0x0f;  // Enable Mask : - - - - PWM3 PWM2 PWM1 PWM0
  57          PWMINFO   _pwm[PWM_CH_NUM];
  58          
  59          
  60          static char _pwm_out;
  61          static char pin15;
  62          
  63          
  64          void UART1_Clear()
  65          {
  66   1        UARTDR = 0xFF;
  67   1      }
  68          
  69          
  70          
  71          void pwm_setup( PWMINFO *pwm, int period, int duty )
  72          {
  73   1        pwm->period     = period;
  74   1        pwm->duty       = duty;
  75   1        pwm->next_duty    = duty;
  76   1        pwm->default_duty = duty;
  77   1        pwm->count    = 0;
  78   1        pwm->out    = 0;
  79   1      }
  80          
  81          
  82          void pwm_init()
  83          {
  84   1      
  85   1        pwm_setup( &_pwm[0], 10, 0 ); // 35
  86   1        pwm_setup( &_pwm[1], 10, 5 ); // 11
  87   1        pwm_setup( &_pwm[2], 10, 5 ); // 12
  88   1        pwm_setup( &_pwm[3], 10, 5 ); // 13
  89   1      
  90   1      }
  91          
  92          void pwm_setup_control( unsigned int pwmflag, unsigned int ctl )
  93          {
  94   1        if( ctl == PWM_CTL_OFF ) 
  95   1        {
  96   2          _pwm_ctl_inc_flag &= ~pwmflag;
  97   2          _pwm_ctl_dec_flag &= ~pwmflag;
  98   2        }
  99   1        else if( ctl == PWM_CTL_DEC ) 
 100   1        {
 101   2          _pwm_ctl_dec_flag |=  pwmflag;
 102   2          _pwm_ctl_inc_flag &= ~pwmflag;
 103   2        }
 104   1        else 
 105   1        {
 106   2          _pwm_ctl_dec_flag &= ~pwmflag;
 107   2          _pwm_ctl_inc_flag |=  pwmflag;
 108   2        }
 109   1      }
 110          
 111          
 112          //======================================================
 113          void pwm_control_Motor()
 114          {
 115   1        // PWM Motor
 116   1        if( _pwm[0].count < _pwm[0].duty && (_pwm_mask & PWM0_FLAG) ) {
 117   2          P3 = 0x20;  // P35
C51 COMPILER V9.60.0.0   MAIN                                                              07/29/2021 13:08:58 PAGE 3   

 118   2        }
 119   1      
 120   1        _pwm[0].count++;
 121   1      
 122   1        
 123   1        if( _pwm[0].count >= _pwm[0].period ) {
 124   2          _pwm[0].count = 0;
 125   2          _pwm[0].duty  = _pwm[0].next_duty;
 126   2          P3 = 0x00;
 127   2        }
 128   1      }
 129          
 130          
 131          void pwm_control_LED()
 132          {
 133   1      
 134   1        _pwm_out = 0;
 135   1        
 136   1        // PWM 1
 137   1        if( _pwm[1].count < _pwm[1].duty && (_pwm_mask & PWM1_FLAG) ) {
 138   2          _pwm_out |= 0x02; // P11
 139   2        }
 140   1      
 141   1        _pwm[1].count++;
 142   1      
 143   1        if( _pwm[1].count >= _pwm[1].period ) {
 144   2          _pwm[1].count = 0;
 145   2          _pwm[1].duty  = _pwm[1].next_duty;
 146   2        }
 147   1      
 148   1      
 149   1        // PWM 2
 150   1        if( _pwm[2].count < _pwm[2].duty && (_pwm_mask & PWM2_FLAG) ) {
 151   2          _pwm_out |= 0x04; // P12
 152   2        }
 153   1      
 154   1        _pwm[2].count++;
 155   1      
 156   1        if( _pwm[2].count >= _pwm[2].period ) {
 157   2          _pwm[2].count = 0;
 158   2          _pwm[2].duty  = _pwm[2].next_duty;
 159   2        }
 160   1      
 161   1      
 162   1        // PWM 3
 163   1        if( _pwm[3].count < _pwm[3].duty && (_pwm_mask & PWM3_FLAG) ) {
 164   2          _pwm_out |= 0x08; // P13
 165   2        }
 166   1      
 167   1        _pwm[3].count++;
 168   1      
 169   1        
 170   1        if( _pwm[3].count >= _pwm[3].period ) {
 171   2          _pwm[3].count = 0;
 172   2          _pwm[3].duty  = _pwm[3].next_duty;
 173   2        }
 174   1      
 175   1        
 176   1        
 177   1        
 178   1        _pwm_out |= 0xF1; // init p10 
 179   1        pin15 = P1 & 0xF0;
C51 COMPILER V9.60.0.0   MAIN                                                              07/29/2021 13:08:58 PAGE 4   

 180   1        
 181   1        P1 = ( pin15 | ~_pwm_out);
 182   1      
 183   1        
 184   1        /*
 185   1          ex) pin 13, 12 high, 11 low 00001100
 186   1               _pwm_out = 0b11111101
 187   1              ~_pwm_out = 0b00000010
 188   1              
 189   1              if P15 low:
 190   1               pin 15 = 0b00100000
 191   1               P1     = 0b00100010
 192   1        
 193   1              else (P15 high):
 194   1               pin 15 = 0b00000000
 195   1               P1 = 0b00000010  
 196   1        
 197   1        */
 198   1        
 199   1      }
 200          
 201          
 202          
 203          void pwm_enable( int pwm0, int pwm1, int pwm2, int pwm3 )
 204          {
 205   1        // 0:Disable 1:Enable -1:Don't care(not change)
 206   1      
 207   1        // B/G/R/Motor
 208   1        if( pwm0 != -1 ) { if( pwm0 ) _pwm_mask |= PWM0_FLAG; else _pwm_mask &= ~PWM0_FLAG; }
 209   1        if( pwm1 != -1 ) { if( pwm1 ) _pwm_mask |= PWM1_FLAG; else _pwm_mask &= ~PWM1_FLAG; }
 210   1        if( pwm2 != -1 ) { if( pwm2 ) _pwm_mask |= PWM2_FLAG; else _pwm_mask &= ~PWM2_FLAG; }
 211   1        if( pwm3 != -1 ) { if( pwm3 ) _pwm_mask |= PWM3_FLAG; else _pwm_mask &= ~PWM3_FLAG; }
 212   1      }
 213          
 214          
 215          //======================================================
 216          void setupOpMode()
 217          {
 218   1        pwm_setup_control( PWM0_FLAG, PWM_CTL_OFF );
 219   1        pwm_setup_control( PWM1_FLAG, PWM_CTL_OFF );
 220   1        pwm_setup_control( PWM2_FLAG, PWM_CTL_OFF );
 221   1        pwm_setup_control( PWM3_FLAG, PWM_CTL_OFF );
 222   1      
 223   1      }
 224          
 225          
 226          void setMotorPWM()
 227          { 
 228   1      
 229   1        if((UARTDR & 0x0F)== 0x00)
 230   1        {
 231   2          P1 &= 0x0F;
 232   2          pwm_enable(0, -1, -1, -1);
 233   2          pwm_setup( &_pwm[0], 10, 0 );
 234   2          UART1_Clear();
 235   2        }
 236   1        
 237   1        else
 238   1        {
 239   2          pwm_enable( 1, -1,-1,-1 );
 240   2          P1 |= 0x20;
 241   2      
C51 COMPILER V9.60.0.0   MAIN                                                              07/29/2021 13:08:58 PAGE 5   

 242   2          if((UARTDR & 0x0F) == 0x01) { pwm_setup( &_pwm[0], 10, 6 );}
 243   2          else if((UARTDR & 0x0F) == 0x02) { pwm_setup( &_pwm[0], 10, 7 );}
 244   2          else if((UARTDR & 0x0F) == 0x03) { pwm_setup( &_pwm[0], 10, 8 );}
 245   2          else if((UARTDR & 0x0F) == 0x04) { pwm_setup( &_pwm[0], 10, 9 );}
 246   2          else if((UARTDR & 0x0F) == 0x05) { pwm_setup( &_pwm[0], 10, 10 );}
 247   2      
 248   2          UART1_Clear();
 249   2        }
 250   1        
 251   1      }
 252          
 253          void setLedPWM(int color) { 
 254   1        
 255   1        /* 
 256   1          B : On
 257   1          G : Good
 258   1          Y : So So
 259   1          M : Bad
 260   1          R : very Bad
 261   1        
 262   1        */
 263   1      
 264   1        if(color == 0){ // B : on
 265   2          pwm_enable(-1, 1, 1, 0);
 266   2          pwm_setup_control( PWM1_FLAG, PWM_CTL_DEC );
 267   2          pwm_setup_control( PWM2_FLAG, PWM_CTL_DEC );
 268   2          pwm_setup_control( PWM3_FLAG, PWM_CTL_INC );
 269   2          UART1_Clear();
 270   2        }
 271   1        
 272   1        else if(color == 1){ // G : Good
 273   2          pwm_enable(-1, 1, 0, 1);
 274   2          pwm_setup_control( PWM1_FLAG, PWM_CTL_DEC );
 275   2          pwm_setup_control( PWM2_FLAG, PWM_CTL_INC );
 276   2          pwm_setup_control( PWM3_FLAG, PWM_CTL_DEC );
 277   2          UART1_Clear();
 278   2        }
 279   1          
 280   1        else if(color == 2){ // Y : So So
 281   2          pwm_enable(-1, 0, 0, 1);
 282   2          pwm_setup_control( PWM1_FLAG, PWM_CTL_INC );
 283   2          pwm_setup_control( PWM2_FLAG, PWM_CTL_INC );
 284   2          pwm_setup_control( PWM3_FLAG, PWM_CTL_DEC );
 285   2          UART1_Clear();
 286   2        }
 287   1      
 288   1        
 289   1        else if(color == 3){ // M : Bad
 290   2          pwm_enable(-1, 0, 1, 0);
 291   2          pwm_setup_control( PWM1_FLAG, PWM_CTL_INC );
 292   2          pwm_setup_control( PWM2_FLAG, PWM_CTL_DEC );
 293   2          pwm_setup_control( PWM3_FLAG, PWM_CTL_INC );
 294   2          UART1_Clear();
 295   2        }
 296   1      
 297   1        else if(color == 4){ // R : very Bad
 298   2          pwm_enable(-1, 0, 1, 1);
 299   2          pwm_setup_control( PWM1_FLAG, PWM_CTL_INC );
 300   2          pwm_setup_control( PWM2_FLAG, PWM_CTL_DEC );
 301   2          pwm_setup_control( PWM3_FLAG, PWM_CTL_DEC );
 302   2          UART1_Clear();
 303   2        }
C51 COMPILER V9.60.0.0   MAIN                                                              07/29/2021 13:08:58 PAGE 6   

 304   1      
 305   1        
 306   1      }
 307          
 308          /*
 309          void setRelayCtrl(int color) {
 310            
 311          }
 312          
 313          */
 314          
 315          void UART_init()
 316          {
 317   1        // initialize UART interface
 318   1        // ASync. 9615bps N 8 1
 319   1        UARTCR2 = 0x02;   // activate UART
 320   1        UARTCR1 = 0x06;   // bit count, parity
 321   1        UARTCR2 |= 0x0D;  // interrupt, speed
 322   1        UARTCR3 = 0x00;   // stop bit
 323   1        UARTBD = 0x0C;    // baud rate
 324   1        UARTST=0x60;    //UDRE TXC RXC WAKE SOFTRST DOR FE PE 
 325   1        // 0x40
 326   1      }
 327          
 328          
 329          
 330          void clock_init()
 331          {
 332   1        // internal RC clock (1.000000MHz)
 333   1        // Nothing to do for the default clock
 334   1      }
 335          
 336          void port_init()
 337          {
 338   1        // initialize ports
 339   1        //   4 : P35      out 
 340   1        //   8 : RXD      in  
 341   1        //   9 : TXD      out 
 342   1        //  10 : P25      in  
 343   1        //  11 : P24      out 
 344   1        //  20 : P13      out 
 345   1        //  21 : P12      out 
 346   1        //  22 : P11      out 
 347   1        P0IO = 0xFF;      // direction
 348   1        P0PU = 0x00;      // pullup
 349   1        P0OD = 0x00;      // open drain
 350   1        P03DB = 0x00;     // bit7~6(debounce clock), bit5~0=P35,P06~02 debounce
 351   1        P0   = 0x00;      // port initial value
 352   1      
 353   1        P1IO = 0xFF;      // direction
 354   1        P1PU = 0x00;      // pullup
 355   1        P1OD = 0x00;      // open drain
 356   1        P12DB = 0x00;     // debounce : P23~20, P13~10
 357   1        P1   = 0x00;      // port initial value
 358   1      
 359   1        P2IO = 0xDF;      // direction
 360   1        P2PU = 0x00;      // pullup
 361   1        P2OD = 0x00;      // open drain
 362   1        P2   = 0x00;      // port initial value
 363   1      
 364   1        P3IO = 0xFD;      // direction
 365   1        P3PU = 0x00;      // pullup
C51 COMPILER V9.60.0.0   MAIN                                                              07/29/2021 13:08:58 PAGE 7   

 366   1        P3OD = 0x00;      // open drain
 367   1        P3   = 0x00;      // port initial value
 368   1      
 369   1        // Set port functions
 370   1        P0FSR = 0x00;     // P0 selection
 371   1        P1FSRH = 0x00;    // P1 selection High
 372   1        P1FSRL = 0x00;    // P1 selection Low
 373   1        P2FSR = 0x00;     // P2 selection
 374   1        P3FSR = 0x01;     // P3 selection
 375   1      }
 376          
 377          static unsigned int _COLOR_LOOP_INDEX = 0;
 378            
 379          void main()
 380          {
 381   1        int i;
 382   1        
 383   1        cli();            // disable INT. during peripheral setting
 384   1        port_init();      // initialize ports
 385   1        clock_init();     // initialize operation clock
 386   1        UART_init();      // initialize UART interface
 387   1        pwm_enable( 0, 1, 1, 1 ); // Motor/ R/ G/ B 
 388   1        pwm_init();
 389   1        pwm_control_Motor();
 390   1        pwm_control_LED();
 391   1        sei();            // enable INT.
 392   1      
 393   1      
 394   1        // TODO: add your main code here
 395   1        UARTDR = 0xFF;
 396   1        
 397   1        setupOpMode();
 398   1        
 399   1        while(1)
 400   1        { 
 401   2          
 402   2          if ((UARTDR & 0x0F) < 0x06)
 403   2            setMotorPWM();    
 404   2      
 405   2          /*
 406   2          F0 : Motor Power On
 407   2          F1 : Motor Power 1
 408   2          F2 : Motor Power 2
 409   2          F3 : Motor Power 3
 410   2          F4 : Motor Power 4
 411   2          F5 : Motor Power 5 (Max)
 412   2          */
 413   2          
 414   2          if (((UARTDR & 0xF0) >> 4) < 0x05)
 415   2          {
 416   3            switch ((UARTDR & 0xF0) >> 4)
 417   3              {
 418   4              case 0x00: 
 419   4                setLedPWM(0); 
 420   4                break;
 421   4              case 0x01: 
 422   4                setLedPWM(1);
 423   4                break;
 424   4              case 0x02: 
 425   4                setLedPWM(2);
 426   4                break;
 427   4              case 0x03: 
C51 COMPILER V9.60.0.0   MAIN                                                              07/29/2021 13:08:58 PAGE 8   

 428   4                setLedPWM(3);
 429   4                break;
 430   4              case 0x04:
 431   4                setLedPWM(4);
 432   4                break;
 433   4      
 434   4            }
 435   3          }
 436   2          
 437   2          /*
 438   2          0F : Motor Power On
 439   2          1F : Motor Power 1
 440   2          2F : Motor Power 2
 441   2          3F : Motor Power 3
 442   2          4F : Motor Power 4
 443   2          5F : Motor Power 5 (Max)
 444   2          */
 445   2          
 446   2          
 447   2          /*
 448   2          for(i = 0; i < 1000; i++) _nop_();  // init delay
 449   2      
 450   2          switch (_COLOR_LOOP_INDEX)
 451   2          {
 452   2            case 0:
 453   2              setLedPWM(0);
 454   2              _COLOR_LOOP_INDEX++;
 455   2              break;
 456   2            
 457   2            case 1:
 458   2              setLedPWM(1);
 459   2              _COLOR_LOOP_INDEX++;
 460   2              break;
 461   2            
 462   2            case 2:
 463   2              setLedPWM(2);
 464   2              _COLOR_LOOP_INDEX++;
 465   2              break;
 466   2            
 467   2            case 3:
 468   2              setLedPWM(3);
 469   2              _COLOR_LOOP_INDEX++;
 470   2              break;
 471   2            
 472   2            case 4:
 473   2              setLedPWM(4);
 474   2              _COLOR_LOOP_INDEX++;
 475   2              break;
 476   2                
 477   2          }
 478   2          if (_COLOR_LOOP_INDEX == 4)
 479   2            _COLOR_LOOP_INDEX = 0;
 480   2          */
 481   2          
 482   2          for (i= 0; i < 10; i++)
 483   2          {
 484   3            pwm_control_Motor();
 485   3            pwm_control_LED();
 486   3          }
 487   2          
 488   2          
 489   2          
C51 COMPILER V9.60.0.0   MAIN                                                              07/29/2021 13:08:58 PAGE 9   

 490   2          
 491   2        }
 492   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1447    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =     68      21
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
