C51 COMPILER V9.60.0.0   MAIN                                                              07/29/2021 11:01:12 PAGE 1   


C51 COMPILER V9.60.0.0, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN main.OBJ
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE main.c LARGE OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND TABS(2)

line level    source

   1          //======================================================
   2          // Main program routine
   3          // - Device name  : MC96F8316
   4          // - Package type : 28SOP
   5          //======================================================
   6          // For XDATA variable : V1.041.00 ~
   7          #define   MAIN  1
   8          
   9          // Generated    : Tue, Jul 27, 2021 (11:47:04)
  10          #include  "MC96F8316.h"
  11          #include  "func_def.h"
  12          #include <stdio.h>
  13          #include <string.h>
  14          
  15          
  16          #define PWM0_FLAG   0x01
  17          #define PWM1_FLAG   0x02
  18          #define PWM2_FLAG   0x04
  19          #define PWM3_FLAG   0x08
  20          
  21          #define PWM_CTL_OFF   0
  22          #define PWM_CTL_INC   1
  23          #define PWM_CTL_DEC   2
  24          
  25          #define PWM_CH_NUM    4
  26          
  27          //======================================================
  28          // interrupt routines
  29          //======================================================
  30          
  31          //======================================================
  32          // peripheral setting routines
  33          //======================================================
  34          
  35          
  36          typedef struct _tagPWMINFO {
  37            int   period;
  38            int   duty;
  39            int   default_duty;
  40            int   next_duty;
  41            int   count;
  42            int   out;
  43          } PWMINFO;
  44          
  45          
  46          
  47          static unsigned int _pwm_ctl_dec_flag = 0;
  48          static unsigned int _pwm_ctl_inc_flag = 0;
  49          static unsigned int _pwm_ctl_cnt = 0;
  50          
  51          static unsigned int _pwm_flag_list[PWM_CH_NUM] = { PWM0_FLAG, PWM1_FLAG, PWM2_FLAG, PWM3_FLAG };
  52          
  53          
  54          
  55          // ----------------------------------
C51 COMPILER V9.60.0.0   MAIN                                                              07/29/2021 11:01:12 PAGE 2   

  56          static int _pwm_mask = 0x0f;  // Enable Mask : - - - - PWM3 PWM2 PWM1 PWM0
  57          PWMINFO   _pwm[PWM_CH_NUM];
  58          
  59          
  60          static char _pwm_out;
  61          static char pin15;
  62          
  63          
  64          void UART1_Clear()
  65          {
  66   1        UARTDR = 0xFF;
  67   1      }
  68          
  69          
  70          
  71          void pwm_setup( PWMINFO *pwm, int period, int duty )
  72          {
  73   1        pwm->period     = period;
  74   1        pwm->duty       = duty;
  75   1        pwm->next_duty    = duty;
  76   1        pwm->default_duty = duty;
  77   1        pwm->count    = 0;
  78   1        pwm->out    = 0;
  79   1      }
  80          
  81          
  82          void pwm_init()
  83          {
  84   1      
  85   1        pwm_setup( &_pwm[0], 10, 0 ); // 35
  86   1        pwm_setup( &_pwm[1], 10, 5 ); // 11
  87   1        pwm_setup( &_pwm[2], 10, 5 ); // 12
  88   1        pwm_setup( &_pwm[3], 10, 5 ); // 13
  89   1      
  90   1      }
  91          
  92          void pwm_setup_control( unsigned int pwmflag, unsigned int ctl )
  93          {
  94   1        if( ctl == PWM_CTL_OFF ) 
  95   1        {
  96   2          _pwm_ctl_inc_flag &= ~pwmflag;
  97   2          _pwm_ctl_dec_flag &= ~pwmflag;
  98   2        }
  99   1        else if( ctl == PWM_CTL_DEC ) 
 100   1        {
 101   2          _pwm_ctl_dec_flag |=  pwmflag;
 102   2          _pwm_ctl_inc_flag &= ~pwmflag;
 103   2        }
 104   1        else 
 105   1        {
 106   2          _pwm_ctl_dec_flag &= ~pwmflag;
 107   2          _pwm_ctl_inc_flag |=  pwmflag;
 108   2        }
 109   1      }
 110          
 111          
 112          //======================================================
 113          void pwm_control_Motor()
 114          {
 115   1        // PWM Motor
 116   1        if( _pwm[0].count < _pwm[0].duty && (_pwm_mask & PWM0_FLAG) ) {
 117   2          P3 = 0x20;  // P35
C51 COMPILER V9.60.0.0   MAIN                                                              07/29/2021 11:01:12 PAGE 3   

 118   2        }
 119   1      
 120   1        _pwm[0].count++;
 121   1      
 122   1        
 123   1        if( _pwm[0].count >= _pwm[0].period ) {
 124   2          _pwm[0].count = 0;
 125   2          _pwm[0].duty  = _pwm[0].next_duty;
 126   2          P3 = 0x00;
 127   2        }
 128   1      }
 129          
 130          
 131          void pwm_control_LED()
 132          {
 133   1      
 134   1        _pwm_out = 0;
 135   1        
 136   1        // PWM 1
 137   1        if( _pwm[1].count < _pwm[1].duty && (_pwm_mask & PWM1_FLAG) ) {
 138   2          _pwm_out |= 0x02; // P11
 139   2        }
 140   1      
 141   1        _pwm[1].count++;
 142   1      
 143   1        if( _pwm[1].count >= _pwm[1].period ) {
 144   2          _pwm[1].count = 0;
 145   2          _pwm[1].duty  = _pwm[1].next_duty;
 146   2        }
 147   1      
 148   1      
 149   1        // PWM 2
 150   1        if( _pwm[2].count < _pwm[2].duty && (_pwm_mask & PWM2_FLAG) ) {
 151   2          _pwm_out |= 0x04; // P12
 152   2        }
 153   1      
 154   1        _pwm[2].count++;
 155   1      
 156   1        if( _pwm[2].count >= _pwm[2].period ) {
 157   2          _pwm[2].count = 0;
 158   2          _pwm[2].duty  = _pwm[2].next_duty;
 159   2        }
 160   1      
 161   1      
 162   1        // PWM 3
 163   1        if( _pwm[3].count < _pwm[3].duty && (_pwm_mask & PWM3_FLAG) ) {
 164   2          _pwm_out |= 0x08; // P13
 165   2        }
 166   1      
 167   1        _pwm[3].count++;
 168   1      
 169   1        
 170   1        if( _pwm[3].count >= _pwm[3].period ) {
 171   2          _pwm[3].count = 0;
 172   2          _pwm[3].duty  = _pwm[3].next_duty;
 173   2        }
 174   1      
 175   1        
 176   1        
 177   1        
 178   1        _pwm_out |= 0xF1; // init p10 
 179   1        pin15 = P1 & 0xF0;
C51 COMPILER V9.60.0.0   MAIN                                                              07/29/2021 11:01:12 PAGE 4   

 180   1        
 181   1        P1 = ( pin15 | ~_pwm_out);
 182   1      
 183   1        
 184   1      
 185   1        /*
 186   1          ex) pin 13, 12 high, 11 low 00001100
 187   1               _pwm_out = 0b11111101
 188   1              ~_pwm_out = 0b00000010
 189   1              
 190   1              if P15 low:
 191   1               P1 = 0b00000010
 192   1              else (P15 high):
 193   1               P1 = 0b00100010  
 194   1        
 195   1        */
 196   1        
 197   1      }
 198          
 199          
 200          
 201          void pwm_enable( int pwm0, int pwm1, int pwm2, int pwm3 )
 202          {
 203   1        // 0:Disable 1:Enable -1:Don't care(not change)
 204   1      
 205   1        // B/G/R/Motor
 206   1        if( pwm0 != -1 ) { if( pwm0 ) _pwm_mask |= PWM0_FLAG; else _pwm_mask &= ~PWM0_FLAG; }
 207   1        if( pwm1 != -1 ) { if( pwm1 ) _pwm_mask |= PWM1_FLAG; else _pwm_mask &= ~PWM1_FLAG; }
 208   1        if( pwm2 != -1 ) { if( pwm2 ) _pwm_mask |= PWM2_FLAG; else _pwm_mask &= ~PWM2_FLAG; }
 209   1        if( pwm3 != -1 ) { if( pwm3 ) _pwm_mask |= PWM3_FLAG; else _pwm_mask &= ~PWM3_FLAG; }
 210   1      }
 211          
 212          
 213          //======================================================
 214          void setupOpMode()
 215          {
 216   1        pwm_setup_control( PWM0_FLAG, PWM_CTL_OFF );
 217   1        pwm_setup_control( PWM1_FLAG, PWM_CTL_OFF );
 218   1        pwm_setup_control( PWM2_FLAG, PWM_CTL_OFF );
 219   1        pwm_setup_control( PWM3_FLAG, PWM_CTL_OFF );
 220   1      
 221   1      }
 222          
 223          
 224          void setMotorPWM()
 225          { 
 226   1      
 227   1        if((UARTDR & 0x0F)== 0x00)
 228   1        {
 229   2          P1 &= 0x0F;
 230   2          pwm_enable(0, -1, -1, -1);
 231   2          pwm_setup( &_pwm[0], 10, 0 );
 232   2          UART1_Clear();
 233   2        }
 234   1        
 235   1        else
 236   1        {
 237   2          pwm_enable( 1, -1,-1,-1 );
 238   2          P1 |= 0x20;
 239   2      
 240   2          if((UARTDR & 0x0F) == 0x01) { pwm_setup( &_pwm[0], 10, 6 );}
 241   2          else if((UARTDR & 0x0F) == 0x02) { pwm_setup( &_pwm[0], 10, 7 );}
C51 COMPILER V9.60.0.0   MAIN                                                              07/29/2021 11:01:12 PAGE 5   

 242   2          else if((UARTDR & 0x0F) == 0x03) { pwm_setup( &_pwm[0], 10, 8 );}
 243   2          else if((UARTDR & 0x0F) == 0x04) { pwm_setup( &_pwm[0], 10, 9 );}
 244   2          else if((UARTDR & 0x0F) == 0x05) { pwm_setup( &_pwm[0], 10, 10 );}
 245   2      
 246   2          UART1_Clear();
 247   2        }
 248   1        
 249   1      }
 250          
 251          void setLedPWM(int color) { 
 252   1        
 253   1        /* 
 254   1          B : On
 255   1          G : Good
 256   1          Y : So So
 257   1          M : Bad
 258   1          R : very Bad
 259   1        
 260   1        */
 261   1      
 262   1        if(color == 0){ // B : on
 263   2          pwm_enable(-1, 1, 1, 0);
 264   2          pwm_setup_control( PWM1_FLAG, PWM_CTL_DEC );
 265   2          pwm_setup_control( PWM2_FLAG, PWM_CTL_DEC );
 266   2          pwm_setup_control( PWM3_FLAG, PWM_CTL_INC );
 267   2          UART1_Clear();
 268   2        }
 269   1        
 270   1        else if(color == 1){ // G : Good
 271   2          pwm_enable(-1, 1, 0, 1);
 272   2          pwm_setup_control( PWM1_FLAG, PWM_CTL_DEC );
 273   2          pwm_setup_control( PWM2_FLAG, PWM_CTL_INC );
 274   2          pwm_setup_control( PWM3_FLAG, PWM_CTL_DEC );
 275   2          UART1_Clear();
 276   2        }
 277   1          
 278   1        else if(color == 2){ // Y : So So
 279   2          pwm_enable(-1, 0, 0, 1);
 280   2          pwm_setup_control( PWM1_FLAG, PWM_CTL_INC );
 281   2          pwm_setup_control( PWM2_FLAG, PWM_CTL_INC );
 282   2          pwm_setup_control( PWM3_FLAG, PWM_CTL_DEC );
 283   2          UART1_Clear();
 284   2        }
 285   1      
 286   1        
 287   1        else if(color == 3){ // M : Bad
 288   2          pwm_enable(-1, 0, 1, 0);
 289   2          pwm_setup_control( PWM1_FLAG, PWM_CTL_INC );
 290   2          pwm_setup_control( PWM2_FLAG, PWM_CTL_DEC );
 291   2          pwm_setup_control( PWM3_FLAG, PWM_CTL_INC );
 292   2          UART1_Clear();
 293   2        }
 294   1      
 295   1        else if(color == 4){ // R : very Bad
 296   2          pwm_enable(-1, 0, 1, 1);
 297   2          pwm_setup_control( PWM1_FLAG, PWM_CTL_INC );
 298   2          pwm_setup_control( PWM2_FLAG, PWM_CTL_DEC );
 299   2          pwm_setup_control( PWM3_FLAG, PWM_CTL_DEC );
 300   2          UART1_Clear();
 301   2        }
 302   1      
 303   1        
C51 COMPILER V9.60.0.0   MAIN                                                              07/29/2021 11:01:12 PAGE 6   

 304   1      }
 305          
 306          /*
 307          void setRelayCtrl(int color) {
 308            
 309          }
 310          
 311          */
 312          
 313          void UART_init()
 314          {
 315   1        // initialize UART interface
 316   1        // ASync. 9615bps N 8 1
 317   1        UARTCR2 = 0x02;   // activate UART
 318   1        UARTCR1 = 0x06;   // bit count, parity
 319   1        UARTCR2 |= 0x0D;  // interrupt, speed
 320   1        UARTCR3 = 0x00;   // stop bit
 321   1        UARTBD = 0x0C;    // baud rate
 322   1        UARTST=0x60;    //UDRE TXC RXC WAKE SOFTRST DOR FE PE 
 323   1        // 0x40
 324   1      }
 325          
 326          
 327          
 328          void clock_init()
 329          {
 330   1        // internal RC clock (1.000000MHz)
 331   1        // Nothing to do for the default clock
 332   1      }
 333          
 334          void port_init()
 335          {
 336   1        // initialize ports
 337   1        //   4 : P35      out 
 338   1        //   8 : RXD      in  
 339   1        //   9 : TXD      out 
 340   1        //  10 : P25      in  
 341   1        //  11 : P24      out 
 342   1        //  20 : P13      out 
 343   1        //  21 : P12      out 
 344   1        //  22 : P11      out 
 345   1        P0IO = 0xFF;      // direction
 346   1        P0PU = 0x00;      // pullup
 347   1        P0OD = 0x00;      // open drain
 348   1        P03DB = 0x00;     // bit7~6(debounce clock), bit5~0=P35,P06~02 debounce
 349   1        P0   = 0x00;      // port initial value
 350   1      
 351   1        P1IO = 0xFF;      // direction
 352   1        P1PU = 0x00;      // pullup
 353   1        P1OD = 0x00;      // open drain
 354   1        P12DB = 0x00;     // debounce : P23~20, P13~10
 355   1        P1   = 0x00;      // port initial value
 356   1      
 357   1        P2IO = 0xDF;      // direction
 358   1        P2PU = 0x00;      // pullup
 359   1        P2OD = 0x00;      // open drain
 360   1        P2   = 0x00;      // port initial value
 361   1      
 362   1        P3IO = 0xFD;      // direction
 363   1        P3PU = 0x00;      // pullup
 364   1        P3OD = 0x00;      // open drain
 365   1        P3   = 0x00;      // port initial value
C51 COMPILER V9.60.0.0   MAIN                                                              07/29/2021 11:01:12 PAGE 7   

 366   1      
 367   1        // Set port functions
 368   1        P0FSR = 0x00;     // P0 selection
 369   1        P1FSRH = 0x00;    // P1 selection High
 370   1        P1FSRL = 0x00;    // P1 selection Low
 371   1        P2FSR = 0x00;     // P2 selection
 372   1        P3FSR = 0x01;     // P3 selection
 373   1      }
 374          
 375          int asd;
 376          
 377          void main()
 378          {
 379   1        int i;
 380   1        
 381   1        cli();            // disable INT. during peripheral setting
 382   1        port_init();      // initialize ports
 383   1        clock_init();     // initialize operation clock
 384   1        UART_init();      // initialize UART interface
 385   1        pwm_enable( 0, 1, 1, 1 ); // Motor/ R/ G/ B 
 386   1        pwm_init();
 387   1        pwm_control_Motor();
 388   1        pwm_control_LED();
 389   1        sei();            // enable INT.
 390   1      
 391   1      
 392   1        // TODO: add your main code here
 393   1        UARTDR = 0xFF;
 394   1        
 395   1        setupOpMode();
 396   1        
 397   1        while(1)
 398   1        {   
 399   2          if ((UARTDR & 0x0F) < 0x06)
 400   2            setMotorPWM();    
 401   2      
 402   2      
 403   2          if (((UARTDR & 0xF0) >> 4) < 0x05)
 404   2          {
 405   3            switch ((UARTDR & 0xF0) >> 4)
 406   3              {
 407   4              case 0x00: 
 408   4                setLedPWM(0); 
 409   4                break;
 410   4              case 0x01: 
 411   4                setLedPWM(1);
 412   4                break;
 413   4              case 0x02: 
 414   4                setLedPWM(2);
 415   4                break;
 416   4              case 0x03: 
 417   4                setLedPWM(3);
 418   4                break;
 419   4              case 0x04:
 420   4                setLedPWM(4);
 421   4                break;
 422   4      
 423   4            }
 424   3          }
 425   2          
 426   2          for (i= 0; i < 10; i++)
 427   2          {
C51 COMPILER V9.60.0.0   MAIN                                                              07/29/2021 11:01:12 PAGE 8   

 428   3            pwm_control_Motor();
 429   3            pwm_control_LED();
 430   3          }
 431   2        }
 432   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1447    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =     68      21
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
